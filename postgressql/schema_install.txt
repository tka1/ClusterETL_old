CREATE SCHEMA cluster
  AUTHORIZATION postgres;


CREATE TABLE cluster.clustertable
CREATE TABLE cluster.clustertable
(
  title character varying,
  decall character varying,
  dxcall character varying,
  freq numeric,
  band character varying,
  country character varying,
  id serial NOT NULL,
  sig_noise character varying,
  datetime timestamp without time zone,
  insert_time timestamp without time zone DEFAULT now(),
  mode character varying,
  de_continent character(2),
  dx_continent character(2),
   info character varying,
  
  CONSTRAINT clustertable_pkey PRIMARY KEY (id)
)

WITH (
  OIDS=FALSE
);
ALTER TABLE cluster.clustertable
  OWNER TO postgres;
GRANT ALL ON TABLE cluster.clustertable TO postgres;
GRANT SELECT, UPDATE, INSERT, TRUNCATE, DELETE ON TABLE cluster.clustertable TO cluster;

-- Index: cluster.title_ind

-- DROP INDEX cluster.title_ind;

CREATE INDEX title_ind
  ON cluster.clustertable
  USING btree
  (title COLLATE pg_catalog."default");


CREATE OR REPLACE VIEW cluster.band_count AS 
 SELECT count(DISTINCT clustertable.dxcall) AS kountti,
    clustertable.band
   FROM cluster.clustertable
  WHERE (now() - clustertable.insert_time::timestamp with time zone) < '01:00:00'::interval
  GROUP BY clustertable.band
  ORDER BY (count(clustertable.dxcall)) DESC;

ALTER TABLE cluster.band_count
  OWNER TO postgres;

  CREATE OR REPLACE VIEW cluster.country_count AS 
 SELECT count(DISTINCT clustertable.dxcall) AS kountti,
    clustertable.country
   FROM cluster.clustertable
  WHERE (now() - clustertable.insert_time::timestamp with time zone) < '01:00:00'::interval
  GROUP BY clustertable.country;

ALTER TABLE cluster.country_count
  OWNER TO postgres;

  CREATE OR REPLACE VIEW cluster.cumul_spot_count AS 
 SELECT count(DISTINCT clustertable.dxcall) AS spot_count,
    to_char(clustertable.insert_time, 'dd/HH24'::text) AS "day/hour"
   FROM cluster.clustertable
  WHERE (now() - clustertable.insert_time::timestamp with time zone) < '48:00:00'::interval
  GROUP BY (to_char(clustertable.insert_time, 'dd/HH24'::text))
  ORDER BY (to_char(clustertable.insert_time, 'dd/HH24'::text));

ALTER TABLE cluster.cumul_spot_count
  OWNER TO postgres;

CREATE OR REPLACE FUNCTION cluster.band_count(
    IN title text,
    IN de_continent text,
    IN mode text,
    OUT kountti bigint,
    OUT band text)
  RETURNS SETOF record AS
$BODY$
 SELECT count(DISTINCT clustertable.dxcall) AS kountti,
    clustertable.band
   FROM cluster.clustertable
  WHERE clustertable.insert_time >= (now() - '01:00:00'::interval)
  and title = left(($1),40)
  and de_continent = left(($2),2)
  and mode like left(($3),6)
  GROUP BY clustertable.band;
  $BODY$
  LANGUAGE sql VOLATILE
  COST 100
  ROWS 1000;
ALTER FUNCTION cluster.band_count(text, text, text)
  OWNER TO postgres;

  
  CREATE OR REPLACE FUNCTION cluster.country_count(
    IN title text,
    IN de_continent text,
    IN mode text,
    OUT kountti bigint,
    OUT country text)
  RETURNS SETOF record AS
$BODY$
SELECT count(clustertable.dxcall) AS kountti,
    clustertable.country
   FROM cluster.clustertable
  WHERE clustertable.insert_time >= (now() - '01:00:00'::interval)
  and title = left(($1),40)
  and de_continent = left(($2),2)
  and mode like left(($3),6)
  GROUP BY clustertable.country;
  $BODY$
  LANGUAGE sql VOLATILE
  COST 100
  ROWS 1000;
ALTER FUNCTION cluster.country_count(text, text, text)
  OWNER TO postgres;

  
  CREATE OR REPLACE FUNCTION cluster.cumul_spot_count(
    IN title text,
    IN de_continent text,
    IN mode text,
    OUT spot_count bigint,
    OUT "day/hour" text)
  RETURNS SETOF record AS
$BODY$
 SELECT count(DISTINCT clustertable.dxcall) AS spot_count,
    to_char(clustertable.insert_time, 'dd/HH24'::text) AS "day/hour"
   FROM cluster.clustertable
  WHERE (now() - clustertable.insert_time::timestamp with time zone) < '48:00:00'::interval
  and title = left(($1),40)
  and de_continent = left(($2),2)
  and mode like left(($3),6)
  GROUP BY to_char(clustertable.insert_time, 'dd/HH24'::text)
  ORDER BY to_char(clustertable.insert_time, 'dd/HH24'::text);

  $BODY$
  LANGUAGE sql VOLATILE
  COST 100
  ROWS 1000;
ALTER FUNCTION cluster.cumul_spot_count(text, text, text)
  OWNER TO postgres;
  
  CREATE OR REPLACE FUNCTION cluster.latestrows(
    IN title text,
    OUT decall text,
    OUT dxcall text,
    OUT country text,
    OUT freq numeric,
    OUT band text,
    OUT mode text,
    OUT sig_noise text,
    OUT datetime timestamp without time zone)
  RETURNS SETOF record AS
$BODY$
SELECT decall,dxcall,country,freq,band,mode,sig_noise,datetime
   FROM cluster.clustertable
  WHERE clustertable.insert_time >= (now() - '0:05:00'::interval)
  and title = left(($1),40)
    order by clustertable.insert_time limit 30;
  $BODY$
  LANGUAGE sql VOLATILE
  COST 100
  ROWS 1000;
ALTER FUNCTION cluster.latestrows(text)
  OWNER TO postgres;


  
  CREATE ROLE cluster LOGIN
   PASSWORD 'xxxxxxxx'
  NOSUPERUSER INHERIT NOCREATEDB NOCREATEROLE NOREPLICATION;

GRANT  USAGE   ON SCHEMA cluster  TO cluster;
GRANT SELECT, UPDATE, INSERT, TRUNCATE, DELETE ON TABLE cluster.clustertable TO cluster;
grant execute on function cluster.band_count(text, text, text) to cluster;
grant execute on function cluster.country_count(text, text, text) to cluster;
grant execute on function cluster.cumul_spot_count(text, text, text) to cluster;
grant execute on function cluster.latestrows(text) to cluster;
GRANT USAGE, SELECT ON SEQUENCE cluster.clustertable_id_seq TO cluster;